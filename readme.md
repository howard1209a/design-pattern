## 23种Java设计模式实例
****
### 总体概述
- 关于抽象父类和子类

    所有子类的共有属性可以放在父类；所有子类都需要实现的方法可以作为抽象方法定义在抽象父类，作为规范；所有子类的共有方法或者模板过程（比如Template Method模式）可以放在抽象父类。
    
    子类的属性是特有属性，子类要实现抽象父类的所有抽象方法，子类可以定义一些自己特有的方法以及静态方法。
### 目录
- [Iterator(常用)](#iterator-迭代器模式-😛)
- [Adapter(常用)](#adapter-适配器模式-🤐)
- [Template Method(常用)](#template-method-模板方法模式-🤭)
- [Factory Method(常用)](#factory-method-工厂方法模式-🤫)
- [Singleton(常用)](#singleton-单例模式-🤩)
- [Prototype(常用)](#prototype-原型模式-🤪)
- [Builder(常用)](#builder-建造者模式-🥵)
- [Abstract Factory(常用)](#abstract-factory-抽象工厂模式-😱)
- [Bridge(常用)](#bridge-桥接模式-😋)
- [Strategy](#strategy-策略模式-🤔)
- [Composite(常用)](#composite-组合模式-🥺)
- [Decorator(常用)](#decorator-装饰器模式-🧐)
- [Visitor](#visitor-访问者模式-😏)
- [Chain of Responsibility(常用)](#chain-of-responsibility-责任链模式-🤫)
- [Facade(常用)](#facade-外观模式-🥰)
- [Mediator(常用)](#mediator-仲裁者模式-😍)
- [Observer(常用)](#observer-观察者模式-🤣)
- [Memento](#memento-快照模式-😴)
- [State](#state-状态模式-🤗)
- [Flyweight(常用)](#flyweight-享元模式-😎)
- [Proxy(常用)](#proxy-代理模式-😀)
- [Command](#command-命令模式-🙄)
- [Interpreter](#interpreter-解释器模式-😏)
### 模式介绍
#### Iterator-迭代器模式 😛
    任何一个存有可遍历元素的类都可以提供一个返回Iterator对象的方法，外部可以通过Iterator接口的hasNext和next方法完成遍历。
#### Adapter-适配器模式 🤐
    一个类实现了一个接口/抽象父类的功能但是与这个接口/抽象父类不匹配，这时可以定义一个新的类，用继承扩展的方式或是委托的方式适配这个接口/抽象父类。

    委托和继承扩展的区别在于委托权限小、是持有的关系，继承扩展权限大、是继承的关系。
#### Template Method-模板方法模式 🤭
    抽象父类定义一些抽象方法并定义一个模板过程，不同的子类对抽象方法做了具体实现，因此模板过程可以产生不同的效果。
#### Factory Method-工厂方法模式 🤫
    Template Method模式中的模板过程用来生成实例，就是Factory Method模式。
#### Singleton-单例模式 🤩
    封装所有构造器，定义一个private static final的本类对象，然后向外部提供public的方法用于获取这个单例。
#### Prototype-原型模式 🤪
    Java中创建对象的三种方式分别是new、反射以及Object类的clone方法，其中new是高耦合、反射和clone是低耦合，new和反射都要走构造器，clone不需要。Object类的clone方法是native、protected的，也就是说任何类的方法中都可以调clone方法克隆this对象自己（需要实现cloneable接口），这个克隆是浅拷贝。
    
    利用clone创建对象的优点是低耦合（不用写死类名，可以用字符串创建对象）以及适合于实例生成太过复杂（很难从头new出一个合适的对象）。
    
    定义一个包含createClone抽象方法的接口或者抽象父类，多个子类通过调clone方法实现createClone方法，定义一个HashMap存储字符串到原型对象的映射。
#### Builder-建造者模式 🥵
    用于组装具有复杂结构的实例，一般是该实例所对应的类提供一个public的静态方法返回一个针对这个类的builder对象，builder对象通过调一系列的方法组装复杂实例，最后调build方法返回组装好的复杂实例。
#### Abstract Factory-抽象工厂模式 😱
    定义抽象工厂和抽象零件，抽象工厂定义创建抽象零件的抽象方法，实现多个具体零件，实现多个具体工厂用于创建各种具体零件。
    
    总体来讲和Factory Method模式非常类似，Factory Method模式也要定义抽象工厂和抽象零件，只不过抽象工厂里是由多个抽象方法组成的模板过程负责创建抽象零件，而具体工厂想要创建具体零件需要实现多个抽象方法。
#### Bridge-桥接模式 😋
    将类的功能层次结构和实现层次结构分离，一方面通过类继承进行功能扩展，一方面通过类继承进行具体实现。

    定义一个抽象父类，子类直接继承去做实现，定义一个类委托这个抽象父类（即持有一个抽象父类对象），在这个类中定义抽象父类中的同名方法并在方法体中实际调抽象父类的对应方法，最后定义子类继承这个类去做功能扩展。
#### Strategy-策略模式 🤔
    整体地替换算法或策略。

    定义一个策略接口，接口中定义策略相关的抽象方法，不同的策略做相应的具体实现。
#### Composite-组合模式 🥺
    简单的K叉树可能就是定义一个节点类，这个节点类可以引用本类，这属于同构节点，而组合模式是异构节点的复合物树。

    定义一个抽象父类表示节点，不同的子类具体实现代表着不同的具体节点类型，某些子类属性中存在抽象父类的列表，就是中间节点，而某些子类没有抽象父类的引用，就是叶节点。
#### Decorator-装饰器模式 🧐
    定义一个抽象父类，定义一个具体实现子类，定义一个装饰器子类，装饰器子类持有一个抽象父类，并借助于这个抽象父类对抽象父类的相关抽象方法做具体实现，这个过程就是装饰，这个类就是装饰类（区别于实现类，实现类是具体实现，装饰类是在具体实现的基础上做装饰）。

    Java中的字符流和字节流就采用装饰器模式，比如Reader是抽象父类、FileReader是Reader的实现类、而BuffedReader是Reader的装饰类（所以叫做包装流）。

    需要注意的是，装饰类可以装饰实现类/装饰类，也就是可以套娃，但是最底层一定是一个实现类。

    装饰器模式的优点在于不修改被装饰的类即可增加功能。
#### Visitor-访问者模式 😏
    将数据结构和对数据的处理分离开来。

    定义数据结构的相关类，定义Visitor访问者类，提供访问各种数据的visit重载方法，把数据传到相应的visit方法内做处理。更进一步的，让被访问者（即数据结构的相关类）定义accept方法，接收Visitor对象并利用Visitor规范定义访问过程。accept方法的出现一方面让被访问者可以自定义访问过程（访问者只能定义对数据的具体操作），另一方面accept方法内部的数据权限更大、安全性更高。
#### Chain of Responsibility-责任链模式 🤫
    链式结构的推卸责任。
    
    定义一个抽象父类Handler，多个子类可以做不同的实现，Handler抽象父类中定义一个抽象方法process，此方法用于实际处理任务，如果能处理就处理后返回true，如果不能处理就直接返回false，Handler抽象父类还需要定义一个handle方法（这是一个Template Method的模板过程），以及一个本类引用作为下一个Handler，在handle方法中首先调process，能处理就结束，不能处理再看是否存在下一个Handler，不存在就报错，存在就调下一个Handler的handle方法，推卸责任。
#### Facade-外观模式 🥰
    封装出一个高层API窗口。

    考虑到系统内部各个类之间的责任关系和依赖关系，按照正确的顺序调用各个类，为互相关联在一起的错综复杂的类整理出高层接口（API）。
#### Mediator-仲裁者模式 😍
    分散的各个组员一有问题就调仲裁，由仲裁者来协调所有组员，组员之间不存在任何耦合关系。

    仲裁者对象持有所有的组员对象并提供仲裁方法，仲裁方法会根据不同情况对所有组员进行综合调度，所有组员都持有仲裁者对象，在发生问题的时候会回调仲裁方法。

    分散组员如果没有仲裁，则组员之间需要相互耦合（持有对方），并且逻辑分散混乱，相反分散组员在有仲裁的情况下，每个组员只需要持有仲裁，耦合度低，且所有逻辑集中在仲裁者，逻辑清晰便于修改。
#### Observer-观察者模式 🤣
    一旦被观察者的状态发生变化，所有的观察者都会立刻响应。
    
    定义一个Observer接口，接口中定义一个update方法，不同的观察者可以做不同的具体实现，被观察者注册了所有的观察者，当状态发生改变的时候会回调所有的观察者update方法。

    观察者模式和仲裁者模式的实现方式类似，都是注册回调，区别在于观察者模式是多个观察者注册到一个被观察者中，仲裁者模式是一个仲裁者注册到每个组员中。
#### Memento-快照模式 😴
    在类中定义两个方法，分别是生成快照对象保存实例状态，以及利用快照对象恢复实例状态，这里实例状态指的是实例字段的值。
#### State-状态模式 🤗
    定义一个state接口，各种依赖于状态的处理会作为抽象方法定义在接口中，定义一些状态类实现state接口，各自实现在当前状态下的处理。在程序中定义一个state接口对象，我们只需要保证状态发生变化时及时更新state接口对象，那么在任何时候调state接口中定义的相应处理就会动态绑定到当前状态的具体处理。

    当状态较多，依赖于状态的处理较多时可以采用状态模式。
#### Flyweight-享元模式 😎
    维护一个对象池，当需要一个对象时，如果对象池中有这个对象，则直接返回池中对象，如果对象池中没有这个对象，则new一个对象，放入池中，然后返回这个对象。

    享元模式的优点是共享对象以减少内存使用量，尤其适用于占用内存多的对象，且这种对象允许共享的情况。
#### Proxy-代理模式 😀
    定义一个委托类和一个代理类实现同一个一致性接口，代理类持有一个委托类但只有在必要的时候才会去创建并调用委托对象，外部的调用者只能看到一致性接口，看不到为他服务的究竟是代理类还是委托类。
    
    本质是一个惰性委托，在一致性接口的调用时，代理能处理则直接处理，不能处理才会创建委托对象并调委托对象去处理。
#### Command-命令模式 🙄
    定义一个Command命令接口，接口中定义一个execute抽象方法，不同命令的execute实现不同。

    将命令作为对象的好处在于，可以通过保存对象序列的方式保存命令序列，从而方便地实现命令相关的历史记录、回退、重现等功能。
#### Interpreter-解释器模式 😏
    利用Composite模式构建一个语法树，定义一个Node抽象父类，在其中定义一个parse抽象方法，parse的作用是对传进来的context进行一段解析然后返回，根节点对象调parse方法对一条程序的完整context对象进行解析，并生成语法树，这个过程是递归方式的深度优先先根建树。然后在Node抽象父类中还可以定义一个execute抽象方法，作用是对语法树进行递归方式的深度优先先根遍历，此先根遍历的特殊之处在于只执行叶节点，中间节点不执行但是可能会循环多次。

    此模式主要用于编写迷你语言的解释器。